package com.concordium.sdk.transactions;

import com.concordium.sdk.crypto.SHA256;
import com.concordium.sdk.exceptions.TransactionCreationException;
import com.concordium.sdk.types.AccountAddress;
import com.concordium.sdk.types.Nonce;
import com.concordium.sdk.types.UInt32;
import com.concordium.sdk.types.UInt64;
import lombok.*;

import java.nio.ByteBuffer;

import static com.google.common.primitives.Bytes.concat;

@Getter
@EqualsAndHashCode(callSuper = true)
@ToString(callSuper = true)
public class AccountTransaction extends BlockItem {

    /**
     * Signature of the transaction. Signature is generated by an Account Holder by Signing the Transaction body.
     */
    private final TransactionSignature signature;

    /**
     * Header for the transaction.
     */
    private final TransactionHeader header;

    /**
     * Transaction payload, defines what this transaction does.
     */
    private final Payload payload;

    /**
     * @param signature Signature of the transaction.
     *                  Signature is generated by an Account Holder by Signing the Transaction body.
     * @param header    Header for the transaction.
     * @param payload   Transaction payload, defines what this transaction does.
     */
    public AccountTransaction(@NonNull TransactionSignature signature,
                              @NonNull TransactionHeader header,
                              @NonNull Payload payload) {
        super(BlockItemType.ACCOUNT_TRANSACTION);
        this.signature = signature;
        this.header = header;
        this.payload = payload;
    }

    /**
     * Sender of this Transaction.
     *
     * @return {@link AccountAddress} of the sender account.
     */
    public AccountAddress getSender() {
        return this.header.getSender();
    }

    /**
     * Sequence number for Account Activity. This should increase monotonically.
     *
     * @return {@link Nonce}.
     */
    public Nonce getNonce() {
        return this.header.getNonce();
    }

    /**
     * Indicates when the transaction should expire.
     */
    public Expiry getExpiry() {
        return this.header.getExpiry();
    }

    final byte[] getBlockItemBytes() {
        return concat(signature.getBytes(), header.getBytes(), getPayload().getBytes());
    }

    /**
     * @param source a buffer to read transaction bytes from, without {@link BlockItemType} byte.
     * @return deserialized {@link AccountTransaction}
     * @throws UnsupportedOperationException if payload can't be read.
     *                                       Not all transaction (payload) types can be read.
     *                                       For unsupported types, get the payload size
     *                                       from the manually read {@link TransactionHeader}
     *                                       and then proceed with {@link RawPayload}.
     */
    public static AccountTransaction fromBytes(ByteBuffer source) {
        return new AccountTransaction(
                TransactionSignature.fromBytes(source),
                TransactionHeader.fromBytes(source),
                Payload.fromBytes(source)
        );
    }

    /**
     * @param sender                  The address of the account that is the source of the transaction.
     * @param nonce                   The sequence number of the transaction, sender (source) account nonce.
     * @param expiry                  A Unix timestamp indicating when the transaction should expire.
     * @param signer                  Signer of the transaction
     * @param payload                 Transaction payload, defines what this transaction does.
     * @param transactionSpecificCost Cost of executing this specific payload
     * @return a ready to submit transaction
     * @throws TransactionCreationException if something went wrong
     * @see TransactionSigner#from(SignerEntry...)
     * @see TransactionTypeCost
     */
    @Builder
    public static AccountTransaction from(@NonNull final AccountAddress sender,
                                          @NonNull final Nonce nonce,
                                          @NonNull final Expiry expiry,
                                          @NonNull final TransactionSigner signer,
                                          @NonNull final Payload payload,
                                          @NonNull UInt64 transactionSpecificCost) {
        try {
            val payloadSize = payload.getBytes().length;
            val header = TransactionHeader
                    .builder()
                    .sender(sender)
                    .nonce(nonce)
                    .expiry(expiry)
                    .payloadSize(UInt32.from(payloadSize))
                    .maxEnergyCost(
                            TransactionHeader.calculateMaxEnergyCost(
                                    signer.size(),
                                    payloadSize,
                                    transactionSpecificCost
                            )
                    )
                    .build();
            val signature = signer.sign(getDataToSign(header, payload));
            return new AccountTransaction(signature, header, payload);
        } catch (Exception e) {
            throw TransactionCreationException.from(e);
        }
    }

    public static byte[] getDataToSign(TransactionHeader header,
                                       Payload payload) {
        return SHA256.hash(
                concat(
                        header.getBytes(),
                        payload.getBytes()
                )
        );
    }
}
