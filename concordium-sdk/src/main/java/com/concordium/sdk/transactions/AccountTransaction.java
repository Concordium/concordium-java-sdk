package com.concordium.sdk.transactions;

import com.concordium.sdk.types.AccountAddress;
import lombok.*;
import java.nio.ByteBuffer;
import static com.google.common.primitives.Bytes.concat;

@Getter
@EqualsAndHashCode(callSuper = true)
@ToString(callSuper = true)
public class AccountTransaction extends BlockItem {

    /**
     * Header for the transaction
     */
    private final TransactionHeader header;

    /**
     * Signature of the transaction. Signature is generated by an Account Holder by Signing the Transaction body.
     */
    private final TransactionSignature signature;

    /**
     * Account Transaction Payload Serialized to bytes.
     */
    private final Payload payload;

    /**
     * Constructor serializing an account transaction
     * @param sender sender of the transaction
     * @param nonce account nonce
     * @param expiry the expiry of the transaction
     * @param signer the {@link Signer} of the transaction
     * @param payload the payload of the transaction
     */
    AccountTransaction(
            @NonNull final AccountAddress sender,
            @NonNull final AccountNonce nonce,
            @NonNull final Expiry expiry,
            @NonNull final TransactionSigner signer,
            @NonNull final Payload payload) {
        this(payload
                .withHeader(TransactionHeader.builder()
                        .sender(sender)
                        .accountNonce(nonce.getNonce())
                        .expiry(expiry.getValue())
                        .build())
                .signWith(signer));
    }

    /**
     * Constructor for deserializing a transaction
     * @param signature the signature
     * @param header the header
     * @param payload the payload
     */
    public AccountTransaction(
            @NonNull final TransactionSignature signature,
            @NonNull final TransactionHeader header,
            @NonNull final Payload payload) {
        this(header, signature, payload);
    }

    AccountTransaction(Payload payload) {
        this(payload.header, payload.signature, payload);
    }

    @Builder(
            builderMethodName = "builderAccountTransactionBlockItem",
            builderClassName = "AccountTransactionBlockItemBuilder")
    AccountTransaction(
            @NonNull final TransactionHeader header,
            @NonNull final TransactionSignature signature,
            @NonNull final Payload payload) {
        super(BlockItemType.ACCOUNT_TRANSACTION);
        this.header = header;
        this.signature = signature;
        this.payload = payload;
    }


    /**
     * Sender of this Transaction.
     *
     * @return {@link AccountAddress} of the sender account.
     */
    public AccountAddress getSender() {
        return this.header.getSender();
    }

    /**
     * Sequence number for Account Activity. This should increase monotonically.
     *
     * @return {@link AccountNonce}.
     */
    public AccountNonce getNonce() {
        return AccountNonce.from(this.header.getAccountNonce());
    }

    /**
     * Indicates when the transaction should expire.
     */
    public Expiry getExpiry() {
        return Expiry.from(this.header.getExpiry().getValue());
    }

    final byte[] getBlockItemBytes() {
        return concat(signature.getBytes(), header.getBytes(), getPayload().getBytes());
    }

    public static AccountTransaction fromBytes(ByteBuffer source) {
        val signature = TransactionSignature.fromBytes(source);
        val header = TransactionHeader.fromBytes(source);
        byte tag = source.get();
        Payload payload;
        switch (tag) {
            case 3:
                payload = Transfer.fromBytes(source);
                break;
            case 21:
                payload = RegisterData.fromBytes(source);
                break;
            case 22:
                payload = TransferWithMemo.fromBytes(source);
                break;
            default:
                throw new UnsupportedOperationException("Only transfers and transfers with memo are currently supported.");
        }

        return new AccountTransaction(signature, header, payload);
    }
}
