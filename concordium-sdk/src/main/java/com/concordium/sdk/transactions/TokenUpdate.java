package com.concordium.sdk.transactions;


import com.concordium.sdk.serializing.CborMapper;
import com.concordium.sdk.transactions.tokens.TokenOperation;
import com.concordium.sdk.types.UInt32;
import com.concordium.sdk.types.UInt64;
import lombok.*;

import java.nio.ByteBuffer;
import java.nio.charset.StandardCharsets;
import java.util.List;

/**
 * A protocol-level token (PLT) transaction payload
 * containing the actual operations.
 */
@ToString
@Builder
@Getter
@EqualsAndHashCode(callSuper = true)
public class TokenUpdate extends Payload {

    /**
     * Symbol (ID) of the token to execute operations on.
     */
    private final String tokenSymbol;

    /**
     * Operations to execute.
     */
    @Singular
    private final List<TokenOperation> operations;

    @Override
    public TransactionType getTransactionType() {
        return TransactionType.TOKEN_UPDATE;
    }

    /**
     * @return CBOR-serialized operations.
     */
    @SneakyThrows
    public byte[] getOperationsSerialized() {
        return CborMapper.INSTANCE
                .writerFor(TokenOperation.LIST_TYPE)
                .writeValueAsBytes(operations);
    }

    @Override
    protected byte[] getRawPayloadBytes() {
        val symbolBytes = tokenSymbol.getBytes(StandardCharsets.UTF_8);
        val operationsBytes = getOperationsSerialized();

        val buffer = ByteBuffer.allocate(
                Byte.BYTES + symbolBytes.length
                        + UInt32.BYTES + operationsBytes.length
        );
        buffer.put((byte) symbolBytes.length);
        buffer.put(symbolBytes);
        buffer.putInt(operationsBytes.length);
        buffer.put(operationsBytes);

        return buffer.array();
    }

    public UInt64 getOperationsBaseCost() {
        var total = UInt64.from(0L);
        for (TokenOperation operation : operations) {
            total = total.plus(operation.getBaseCost());
        }
        return total;
    }

    public static TokenUpdate fromBytes(ByteBuffer source) {
        val symbolBytesLength = source.get();
        val symbolBytes = new byte[symbolBytesLength];
        source.get(symbolBytes);
        val tokenSymbol = new String(symbolBytes, StandardCharsets.UTF_8);

        val operationsBytesLength = source.getInt();
        val operationsBytes = new byte[operationsBytesLength];
        source.get(operationsBytes);

        return TokenUpdate
                .builder()
                .tokenSymbol(tokenSymbol)
                .operationsSerialized(operationsBytes)
                .build();
    }

    @SuppressWarnings("unused")
    public static class TokenUpdateBuilder {

        // This class is merged with the one
        // generated by the @Builder annotation.

        @SneakyThrows
        public TokenUpdateBuilder operationsSerialized(byte[] operationsSerialized) {
            return operations(
                    CborMapper.INSTANCE
                            .readerFor(TokenOperation.LIST_TYPE)
                            .readValue(operationsSerialized)
            );
        }
    }
}
